#include<stdio.h>
//写一段代码告诉我们当前的字节序是什么 
//大端模式：指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中 
//小端模式：指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中 
//0x11223344 ；44属于低位，11是高位。在内存条中从左到右是低位到高位，且排列顺序以字节为单位。电脑中小端和大端都有可能
//小端：14 00 00 00
//大端：00 00 00 14 
int main()
{
	int a=1;
	char* p=(char*)&a;//char*可以存放四个或八个字节的地址，但是一次只能操作一个字节，用其判断a地址的第一个字节是00还是01。a是整数与char*不兼容，故要把a的地址取出来转化一下类型，但其类型不变
	if(*p==1)//p只能访问一个字节，如果p==1则代表p第一个字节是01，则代表操作环境是小端 
	{
		printf("小端");
	}
	else
	{
		printf("大端");
	}
	return 0;
}


#include<stdio.h> 
//返回1是小端，返回0是大端
int check_sys() //不需要参数，因为我自己创建参数a 
{
	int a=1;
	char* p=(char*)&a;
		return *(char*)&a;//把a的地址取出来转化为char*类型，（char*）&a本质上还是地址。*(char*)&a,是对a的地址进行访问，且只能访问一个字节 
}
int main()
{
	int ret=check_sys(); //只是需要判断，不需要打印 
	if(ret==1)
	{
		printf("小端");
	}
	else
	{
		printf("大端");
	}
	return 0;
}

#include<stdio.h> 
//整形提升：在输出或者计算变量时，变量大小不够int型的大小时需要把变量的大小提升到整形然后进行输出或计算 
//c语言中计算机打印整数时打印的是他的原码 
int main()
{
	char a=-1;//负数在内存中存的是补码形式：111111111111111111111111111111 
	//11111111,因为是小端，所以a存的是最后八位1。高位为符号位1，则提升时全部补1，成为补码；11111111111111111111111111111 ，其原码是10000000000000000000000000000001，则打印-1 
	signed char b=-1;//b存放的也是这8个比特位.此处的a与b数值相等，打印的也是-1 
	unsigned char c=-1;//c同理放的是八个比特位111111111，但是最高位不是符号位。无符号数整形提升时补0，00000000000000000000000011111111。最高位是0，属于正数，正数的原反补相同 
	printf("a=%d b=%d c=%d",a,b,c);//a，b，c打印的都是整形 
	return 0;
}


#include<stdio.h> 
int main()
{
	char a=-128;//原码：10000000000000000000010000000。补码：11111111111111111111111110000000
	//最后八位10000000存进内存。整形提升：111111111111111111111110000000，还是补码。 
	printf("%u",a);//%d是打印十进制的有符号数字，%u是打印十进制无符号数字。%u的意思是让系统按照无符号的形式进行打印，认为内存中是无符号数，且无符号数原反补相同，照其打印 
	return 0;
}

char类型占1个字节，八个比特位，补码范围是00000000到11111111， 
有符号位signed：正数原，反补码是00000000到01111111，十进制正数范围是0到127。负数补码是1000000到11111111，原码是10000001到1111111（补码为10000000时，十进制默认为-128），十进制范围是-1到-128
                则有符号位的char的范围是-128到127 
无符号位unsigned ：最高位不是符号位而是有效位，无负数。八比特位是0000000到11111111且原反补相同。十进制是0到255

 

